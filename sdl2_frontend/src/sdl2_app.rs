use crc32fast::Hasher;
use log::{error, info};
use rust_nes::apu::Apu;
use rust_nes::cartridge::{CartridgeHeader, CpuCartridgeAddressBus, PpuCartridgeAddressBus};
use rust_nes::cpu::Cpu;
use rust_nes::io::Io;
use rust_nes::io::{Button, Controller};
use rust_nes::ppu::{Ppu, PpuIteratorState};
use sdl2::audio::AudioSpecDesired;
use sdl2::event::Event;
use sdl2::keyboard::Keycode;
use sdl2::pixels::PixelFormatEnum;
use std::fs::File;
use std::io::Write;
use std::{thread, time};

/// Used to perform a FIR low pass filter on samples generated by the APU prior
/// to downsampling
const FIR_FILTER: [f32; 41] = [
    0.000191, 0.000455, 0.000889, 0.001545, 0.002473, 0.003718, 0.005315, 0.007283, 0.009625, 0.012319, 0.015321,
    0.018561, 0.021946, 0.025366, 0.028698, 0.031809, 0.034570, 0.036860, 0.038577, 0.039640, 0.040000, 0.039640,
    0.038577, 0.036860, 0.034570, 0.031809, 0.028698, 0.025366, 0.021946, 0.018561, 0.015321, 0.012319, 0.009625,
    0.007283, 0.005315, 0.003718, 0.002473, 0.001545, 0.000889, 0.000455, 0.000191,
];

struct AudioDac {
    sample_buffer: Vec<f32>,
    presample_buffer: [f32; 41],
    presample_pointer: usize,
}

impl AudioDac {
    fn new() -> Self {
        AudioDac {
            sample_buffer: vec![],
            presample_buffer: [0f32; 41],
            presample_pointer: 0,
        }
    }

    fn add_sample(&mut self, sample: f32) {
        // Roughly 40.5 generated per sample output so we spread the 41st pre sample between
        // one sample and the next
        let adjust = match self.presample_pointer {
            0 => 0.483f32,
            1 => 0.517f32,
            _ => 1f32,
        };
        self.presample_buffer[self.presample_pointer] = sample * adjust;
        self.presample_pointer += 1;

        if self.presample_pointer == self.presample_buffer.len() {
            self.sample_buffer.push(self.down_sample_buffer());
            self.presample_pointer = 0;
        }
    }

    fn down_sample_buffer(&self) -> f32 {
        self.presample_buffer
            .iter()
            .zip(FIR_FILTER.iter())
            .map(|(s, f)| s * f)
            .fold(0f32, |a, b| a + b)
    }
}

pub(crate) fn run(
    screen_width: u32,
    screen_height: u32,
    prg_address_bus: Box<dyn CpuCartridgeAddressBus>,
    chr_address_bus: Box<dyn PpuCartridgeAddressBus>,
    cartridge_header: CartridgeHeader,
) -> std::io::Result<()> {
    let sdl = sdl2::init().unwrap();

    // Set up audio subsystem
    let audio = sdl.audio().unwrap();
    let desired_spec = AudioSpecDesired {
        freq: Some(44_100),
        channels: Some(1),
        samples: Some(1024),
    };
    let audio_device = audio.open_queue::<f32, _>(None, &desired_spec).unwrap();
    audio_device.resume();

    // Set up video subsystem
    let video_subsystem = sdl.video().unwrap();
    let window = video_subsystem
        .window(
            &format!("NES - {:}", cartridge_header),
            screen_width * 2,
            screen_height * 2,
        )
        .build()
        .unwrap();

    let mut canvas = window.into_canvas().build().map_err(|e| e.to_string()).unwrap();
    let texture_creator = canvas.texture_creator();

    let mut texture = texture_creator
        .create_texture_streaming(PixelFormatEnum::ARGB8888, screen_width, screen_height)
        .map_err(|e| e.to_string())
        .unwrap();

    let mut event_pump = sdl.event_pump().unwrap();

    let mut apu = Apu::new();
    let mut io = Io::new();
    let mut ppu = Ppu::new(chr_address_bus);
    let mut cpu = Cpu::new(prg_address_bus, &mut apu, &mut io, &mut ppu);
    let mut time_of_last_render = time::Instant::now();
    let frame_duration = time::Duration::from_millis(17);
    let mut is_paused = false;
    let mut dac = AudioDac::new();

    'main: loop {
        if !is_paused {
            let (ppu_state, apu_sample) = cpu.next().unwrap();

            if let Some(sample) = apu_sample {
                dac.add_sample(sample);
            }

            if let Some(PpuIteratorState::ReadyToRender) = ppu_state {
                info!("Frame complete, rendering");

                let framebuffer = cpu.get_framebuffer();
                texture.update(None, framebuffer, screen_width as usize * 4).unwrap();
                canvas.clear();
                canvas.copy(&texture, None, None).unwrap();
                canvas.present();

                for event in event_pump.poll_iter() {
                    info!("{:?}", event);
                    match event {
                        Event::Quit { .. }
                        | Event::KeyDown {
                            keycode: Some(Keycode::Escape),
                            ..
                        } => {
                            info!("Quitting emulation");
                            break 'main;
                        }
                        Event::KeyDown {
                            keycode: Some(keycode), ..
                        } => match keycode {
                            Keycode::Z => cpu.button_down(Controller::One, Button::A),
                            Keycode::X => cpu.button_down(Controller::One, Button::B),
                            Keycode::Return => cpu.button_down(Controller::One, Button::Start),
                            Keycode::Tab => cpu.button_down(Controller::One, Button::Select),
                            Keycode::Left => cpu.button_down(Controller::One, Button::Left),
                            Keycode::Right => cpu.button_down(Controller::One, Button::Right),
                            Keycode::Up => cpu.button_down(Controller::One, Button::Up),
                            Keycode::Down => cpu.button_down(Controller::One, Button::Down),
                            Keycode::Space => {
                                if is_paused {
                                    audio_device.resume();
                                } else {
                                    audio_device.pause();
                                }
                                is_paused = !is_paused;
                            }
                            Keycode::T => {
                                let framebuffer = cpu.get_framebuffer();
                                let cycles = cpu.cycles;
                                let mut hasher = Hasher::new();
                                hasher.update(framebuffer);
                                let checksum = hasher.finalize();

                                println!("Cycles: {:X}, FrameBuffer CRC32, {:}", cycles, checksum);
                            }
                            Keycode::D => {
                                // Dump contents of PPU
                                let mut vram = [0; 0x4000];
                                let oam_ram = cpu.dump_ppu_state(&mut vram);
                                let mut vram_file = File::create("vram.csv").unwrap();
                                let mut oam_ram_file = File::create("oam_ram.csv").unwrap();

                                for b in vram.iter() {
                                    writeln!(vram_file, "{:02X}", b)?;
                                }

                                for b in oam_ram.iter() {
                                    writeln!(oam_ram_file, "{:02X}", b)?;
                                }
                            }
                            _ => (),
                        },
                        Event::KeyUp {
                            keycode: Some(keycode), ..
                        } => match keycode {
                            Keycode::Z => cpu.button_up(Controller::One, Button::A),
                            Keycode::X => cpu.button_up(Controller::One, Button::B),
                            Keycode::Return => cpu.button_up(Controller::One, Button::Start),
                            Keycode::Tab => cpu.button_up(Controller::One, Button::Select),
                            Keycode::Left => cpu.button_up(Controller::One, Button::Left),
                            Keycode::Right => cpu.button_up(Controller::One, Button::Right),
                            Keycode::Up => cpu.button_up(Controller::One, Button::Up),
                            Keycode::Down => cpu.button_up(Controller::One, Button::Down),
                            _ => (),
                        },
                        _ => (),
                    };
                }

                // Wait so that we render at 60fps
                let diff = time::Instant::now() - time_of_last_render;
                if diff < frame_duration {
                    info!("Sleeping {:?}", frame_duration - diff);
                    thread::sleep(frame_duration - diff);
                }
                time_of_last_render = time::Instant::now();

                // Make sure that the audio is sync'd to the framerate before queuing more
                while audio_device.size() > 0 {}
                audio_device.queue(&dac.sample_buffer.as_slice());
                dac.sample_buffer.clear();
            }
        }
    }

    Ok(())
}
